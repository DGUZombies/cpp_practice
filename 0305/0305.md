# 2020-03-05

# Part 01 C++로의 전환
## Chapter 01 C언어 기반의 c++
---
### 01-3 매개변수의 디폴트 값(Default Value) 

#### 매개변수에 설정하는 '디폴트 값'의 의미
- 매개변수에 기본적으로 값을 설정할 수 있다.
```
int MyFuncOne(**int num=7**)
{
	return num+1;
}
``` 
- 함수호출 시 인자를 전달하지 않으면 7이 전달된 것으로 간주하겠다는 뜻
- MyFuncOne()과 MyFuncOne(7)은 완전히 동일한 호출문이다. 
- 매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.

#### 디폴트 값은 함수의 선언 부분에만 표현하면 됩니다. 
- 함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 **함수의 원형 선언에만 위치시켜야 한다.**

#### 부분적 디폴트 값 설정
- 함수 선언 시 일부분만 디폴트 값을 설정 할 수 있다.
- 반드시 오른쪽 매개변수의 디폴트 값부터 채우는 형태로 정의해야 한다.
- 왜냐면 매개변수를 전달하면 왼쪽부터 채워지니까 

#### 문제 01-3 [매개변수의 디폴트 값]
- 매개변수를 void로 하거나 int num=10인 경우는 매개변수 없이 함수 호출 할 경우 어떤 함수를 호출해야 할지 몰라서 에러 발생 
- Call of overloaded 'SimpleFunc()' is ambiguous
 
### 01-4 인라인(inline) 함수
- 프로그램 코드라인 안으로 들어가버린 함수 

#### 매크로 함수의 장점 
- C언어에서 매크로 함수의 장점: 일반적인 함수에 비해서 실행속도의 이점이 있다.
- 단점: 정의하기가 어렵다. 복잡한 함수를 매크로의 형태로 정의하는데 한계가 있다.
- 전처리 과정 거치면 함수의 몸체부분이 함수의 호출문을 대체한다. => 함수가 인라인화 되었다. 
- 매크로 함수는 정의하기가 복잡하다 => 인라인 함수가 이를 대체 할 수 있음

#### C++ 기반의 인라인 함수 정의
```
inline int SQUARE(int x)
{
	return x*x;
}
``` 
- 키워드 inline의 선언 통하여 함수 SQUARE를 인라인 함수로 만든거임
- inline 쓴 함수의 인라인화는 전처리기가 아닌 컴파일러에 의해 처리된다.
- 컴파일러가 이를 성능에 해가 된다고 판단할 경우, 이 키워드를 무시하기도 하고 일부 함수를 임의로 인라인 처리하기도 한다.

#### 매크로 함수에는 있지만, 인라인 함수에는 없는 장점
- 매크로 함수는 자료형에 의존적이지 않은 함수가 된다. 즉 변환이 자동으로 이루어져 어떠한 경우에도 데이터의 손실이 발생하지 않는다.
- 그러나 인라인 함수는 매개변수 선언을 할 때 자료형을 쓰니깐 다른 자료형으로 함수 호출하면 데이터 손실이 발생한다.
- 이를 방지하려면 템플릿을 이용하면 되는데, 나중에 배움
```
template <typename T>
inline T SQUARE(T x)
{
	return x*x;
}
```

### 01-5 이름공간(namespace)에 대한 소개
- 특정 영역에 이름을 붙여주기 위한 문법적인 요소

#### 이름공간의 등장배경
- 프로그램이 대형화 되어 가면서 이름 충돌의 문제가 등장
- 규모가 큰 프로젝트에서 일을 구분하여 독립적으로 진행 후 마지막에 합치는 경우 함수 이름이 중복되는 문제가 발견

#### 이름공간의 기본 원리
- 이름과 매개변수의 형이 동일하여서 함수 오버로딩도 만족하지 못하는 경우
- 자신만의 이름공간을 만들고 이 안에 함수를 정의하거나 변수를 선언하면 된다.
```
namespace 이름공간이름
{
	// 이름공간 내부
	// 여기다 함수 선언이나 변수 선언함 
}
```
- 이름공간::함수이름 과 같은 방식으로 접근하면 된다.
- 연산자 ::는 범위지정 연산자(scope resolution operator)라 하고, 이름공간을 지정할 때 사용하는 연산자이다.

#### 이름공간 기반의 함수 선언과 정의의 구분
- 함수 선언은 헤더파일에, 함수 정의는 소스파일에 들어가는데 이를 구분하는 방법은 아래와 같다.
- 함수 호출 뿐만 아니라 함수 선언에도 범위지정 연산자를 씀. 
```
#include <iostream>

namespace BestComImpl
{
	void SimpleFunc(void);	// 함수선언 
}

...
int main()
...

Void **BestComImpl::**SimpleFun(void)
{
	// 함수정의
	// 여기는 BestComImpl의 이름공간이므로 이 이름공간에서 선언된 다른 함수나 변수를 호출할 때는 다시 이름공간을 명시할 필요가 없다.
	// 물론 다른 이름공간의 함수 호출할 때는 이름공간 써줘야 함. 
}
```
 
#### 이름공간의 중첩
- 이름공간 속에 또 이름공간이 선언될 수 있다.
- ::연산자로 순차적으로 접근하면 됨 

#### 문제 01-4 [파일의 분할]
- 헤더파일: 일반적으로 함수나 구조체등의 선언만 포함한다. 
- 소스파일: 헤더 파일에서 선언한 함수 등의 실질적인 정의를 쓴다. 위 헤더파일을 include해야한다. 
- 메인 소스파일: 메인 함수가 들어있는 소스 파일로 프로그램의 진행을 쭉 쓰면 된다.

#### std::cout, std::in, std::endl
- 헤더파일 <iostream>에 선언되어 있는 cout, in, endl은 이름공간 std안에 선언되어 있군

#### using을 이용한 이름공간의 명시
- 일일이 이름공간을 ::로 선언할 필요 없이 키워드 using을 사용하면 계속해서 호출 할 수 있다.
```
	using Hybrid::HybFunc; 
```
- 요걸 main 내에서 쓰면 지역 변수 선언처럼 사용되는 것
- 프로그램 전체에 영향을 미치게 하고 싶다면 함수 밖에 선언하면 됨
```
	using namespace std;
```
- 이런식으로 이름공간 std에 선언된 모든 것에 대해 이름공간 지정의 생략을 명령할 수 있다.

#### 이름공간의 별칭 지정
- 이름 공간이 많이 중첩될 경우, 별칭 지정이 가능
```
	namespace ABC=AAA::BBB::CCC'
```
- ABC로 접근이 가능
- 별칭 선언은 아무데서나 가능한 것 같고 선언한 이후부터 효력을 미친다.

#### 범위지정 연산자(Scope Resolution Operator)의 또 다른 기능
- 지역변수의 이름이 전역번수와 같을 경우, 전역변수는 지역변수에 의해 가려진다.
- 전역변수에 접근하고 싶다면 그냥 앞에 ::를 붙이면 된다. 
