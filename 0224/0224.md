# 2020-02-24

# Part 01 C++로의 전환
## Chapter 01 C언어 기반의 c++
---
### 01-1 printf와 scanf를 대신하는 입출력 방식 

#### 문자열 "Hello World"의 출력
- 확장자: .cpp
- 헤더 파일 선언문이 iostream
- std::cout과 <<를 이용하여 출력 
- std::endl을 이용하여 개행 

#### 관찰결과1: 헤더파일 선언문 #include <iostream>
- c언어: 입출력을 위한 printf, scanf 호출하려면 <stdio.h>를 포함해야 했다.
- c++에서는 입출력에 관련된 일을 하기 위하여 **<iostream>** 헤더파일을 추가한다.
- c++에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하도록 약속되어 있다. (c++ 표준의 변경으로 인함)

#### 관찰결과2: std::cout과 << 연산자를 이용한 출력
``` 
std::cout<< '출력대상';
```
- C언어와 달리 서식문자를 이용하여 별도의 출력포맷을 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이루어 진다.

#### 관찰결과3: <<연산자를 이용한 출력대상의 연이은 표현과 개행
- **<<연산자**를 이용하면 둘 이상의 출력 대상을 연이어 출력 할 수 있다.
```
std::cout<<'출력대상1'<<'출력대상2'<<'출력대상3';
```
- <<연상자를 이용한 std::endl의 출력은 개행으로 이어진다.

#### scanf를 대신하는 데이터의 입력
- 키보드로부터의 데이터 입력에도 헤더파일 선언문 #include <iostrea>이 필요
- 키보드로부터의 데이터 입력에는 std::cin과 >> 연산자가 사용됨
- **변수 선언은 어디서든 가능** 

#### 관찰결과1: 데이터의 입력에 사용되는 std::cin과 >> 연산자
```
std::cin>>변수;
```
- c언어와 달리 데이터의 입력에도 별도의 포맷 지정이 필요 없음
- 문자열 입력은 다음과 같다
```
char str[100];
std::cin>>str;
```

#### 관찰결과2: C++의 지역변수 선언
- C언어는 지역변수 선언이 항상 제일 먼저 등장해야만 했음
- C++의 지역변수는 함수 내 어디든 삽입이 가능
```
std::cin>>'변수1'>>'변수2';
```
- 위와 같은 구조로 연속적인 데이터의 입력을 요구할 수 있음
- 두 데이터는 탭, 스페이스 바, Enter 키 같은 공백에 의해 나눠짐
- for문의 초기화 문장 내에서 변수 선언이 가능
```
for(int num=0; num<10; num++) {...}
```

#### 배열 기반의 문자열 입출력
- std::endl대신 '\n'도 써도 됨 
 
#### 문제 01-1 [C++ 기반의 데이터 입출력]
- 따로 첨부 
- if문에서 일치하냐는 == 임...대입연산자 =가 아니라  ㅡㅡ.. 
---
### 01-2 함수 오버로딩(Function Overloading)

#### 함수 오버로딩의 이해
- C언어에서는 동일한 이름의 함수가 정의되는 것을 허용 X 
- 함수호출 시 전달되는 인자를 통해 함수가 구분 될 수 있으므로, **매개변수의 선언형태가 다르면 동일한 이름의 함수 정의가 가능함**
- 이것이 **Function Overloading**
- C언어는 함수 이름만 사용하여 호출 대상을 찾고, C++은 함수의 이름과 매개변수의 선언을 둘 다 사용하므로 이것이 가능한 것임

#### 함수 오버로딩의 예 
- 오버로딩이 가능하려면 **매개변수의 자료형 또는 개수가 달라야 함**
- 반환형은 함수 호출 시 호출되는 함수를 구분하는 기준이 될 수 없으므로 반환형이 다르다 해서 함수 오버로딩이 가능한 것은 아님 -> 컴파일 오류 ^^

#### 문제 01-2 [함수 오버로딩]
- &(주소 연산자): 변수의 메모리 주소를 구할 대 변수 앞에 붙임
- %p, %x, %X 를 이용하여 출력  
- 포인터 변수: *를 사용하여 선언, 메모리 주소를 저장함 
```
자료형* 포인터이름;
포인터 = &변수; 
```
- 즉 포인터는 특정 메모리 주소를 가지는 공간을 가리키고 있는 것과 같다. 
- 역참조(dereference) 연산자 *:  포인터 앞에 붙여 해당 포인터에 저장된 메모리 주소로 가서 '값'을 가져옴
 
